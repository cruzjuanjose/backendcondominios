
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models.js"
import { type PrismaClient } from "./class.js"

export type * from '../models.js'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.1.0
 * Query Engine version: ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba
 */
export const prismaVersion: PrismaVersion = {
  client: "7.1.0",
  engine: "ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  assignment_type: 'assignment_type',
  bank_account: 'bank_account',
  country: 'country',
  maintenance: 'maintenance',
  maintenance_payment: 'maintenance_payment',
  payment_order: 'payment_order',
  payment_order_person: 'payment_order_person',
  payment_type: 'payment_type',
  permission_type: 'permission_type',
  person: 'person',
  person_email: 'person_email',
  person_phone: 'person_phone',
  property: 'property',
  property_bank_account: 'property_bank_account',
  property_item: 'property_item',
  property_item_type: 'property_item_type',
  property_payment_config: 'property_payment_config',
  property_type: 'property_type',
  provider: 'provider',
  provider_bank_account: 'provider_bank_account',
  provider_category: 'provider_category',
  provider_provider_category: 'provider_provider_category',
  receipt: 'receipt',
  receipt_detail: 'receipt_detail',
  role: 'role',
  role_permission: 'role_permission',
  screen: 'screen',
  service_contract: 'service_contract',
  service_contract_person: 'service_contract_person',
  subproperty: 'subproperty',
  subproperty_item: 'subproperty_item',
  subproperty_person: 'subproperty_person',
  subproperty_type: 'subproperty_type',
  user_account: 'user_account',
  user_property_role: 'user_property_role',
  vehicle: 'vehicle',
  vehicle_type: 'vehicle_type',
  visit: 'visit',
  visit_type: 'visit_type'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "assignment_type" | "bank_account" | "country" | "maintenance" | "maintenance_payment" | "payment_order" | "payment_order_person" | "payment_type" | "permission_type" | "person" | "person_email" | "person_phone" | "property" | "property_bank_account" | "property_item" | "property_item_type" | "property_payment_config" | "property_type" | "provider" | "provider_bank_account" | "provider_category" | "provider_provider_category" | "receipt" | "receipt_detail" | "role" | "role_permission" | "screen" | "service_contract" | "service_contract_person" | "subproperty" | "subproperty_item" | "subproperty_person" | "subproperty_type" | "user_account" | "user_property_role" | "vehicle" | "vehicle_type" | "visit" | "visit_type"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    assignment_type: {
      payload: Prisma.$assignment_typePayload<ExtArgs>
      fields: Prisma.assignment_typeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.assignment_typeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$assignment_typePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.assignment_typeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$assignment_typePayload>
        }
        findFirst: {
          args: Prisma.assignment_typeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$assignment_typePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.assignment_typeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$assignment_typePayload>
        }
        findMany: {
          args: Prisma.assignment_typeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$assignment_typePayload>[]
        }
        create: {
          args: Prisma.assignment_typeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$assignment_typePayload>
        }
        createMany: {
          args: Prisma.assignment_typeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.assignment_typeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$assignment_typePayload>
        }
        update: {
          args: Prisma.assignment_typeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$assignment_typePayload>
        }
        deleteMany: {
          args: Prisma.assignment_typeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.assignment_typeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.assignment_typeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$assignment_typePayload>
        }
        aggregate: {
          args: Prisma.Assignment_typeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssignment_type>
        }
        groupBy: {
          args: Prisma.assignment_typeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Assignment_typeGroupByOutputType>[]
        }
        count: {
          args: Prisma.assignment_typeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Assignment_typeCountAggregateOutputType> | number
        }
      }
    }
    bank_account: {
      payload: Prisma.$bank_accountPayload<ExtArgs>
      fields: Prisma.bank_accountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.bank_accountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$bank_accountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.bank_accountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$bank_accountPayload>
        }
        findFirst: {
          args: Prisma.bank_accountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$bank_accountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.bank_accountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$bank_accountPayload>
        }
        findMany: {
          args: Prisma.bank_accountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$bank_accountPayload>[]
        }
        create: {
          args: Prisma.bank_accountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$bank_accountPayload>
        }
        createMany: {
          args: Prisma.bank_accountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.bank_accountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$bank_accountPayload>
        }
        update: {
          args: Prisma.bank_accountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$bank_accountPayload>
        }
        deleteMany: {
          args: Prisma.bank_accountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.bank_accountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.bank_accountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$bank_accountPayload>
        }
        aggregate: {
          args: Prisma.Bank_accountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBank_account>
        }
        groupBy: {
          args: Prisma.bank_accountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Bank_accountGroupByOutputType>[]
        }
        count: {
          args: Prisma.bank_accountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Bank_accountCountAggregateOutputType> | number
        }
      }
    }
    country: {
      payload: Prisma.$countryPayload<ExtArgs>
      fields: Prisma.countryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.countryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$countryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.countryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$countryPayload>
        }
        findFirst: {
          args: Prisma.countryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$countryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.countryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$countryPayload>
        }
        findMany: {
          args: Prisma.countryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$countryPayload>[]
        }
        create: {
          args: Prisma.countryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$countryPayload>
        }
        createMany: {
          args: Prisma.countryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.countryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$countryPayload>
        }
        update: {
          args: Prisma.countryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$countryPayload>
        }
        deleteMany: {
          args: Prisma.countryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.countryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.countryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$countryPayload>
        }
        aggregate: {
          args: Prisma.CountryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCountry>
        }
        groupBy: {
          args: Prisma.countryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CountryGroupByOutputType>[]
        }
        count: {
          args: Prisma.countryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CountryCountAggregateOutputType> | number
        }
      }
    }
    maintenance: {
      payload: Prisma.$maintenancePayload<ExtArgs>
      fields: Prisma.maintenanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.maintenanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.maintenanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenancePayload>
        }
        findFirst: {
          args: Prisma.maintenanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.maintenanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenancePayload>
        }
        findMany: {
          args: Prisma.maintenanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenancePayload>[]
        }
        create: {
          args: Prisma.maintenanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenancePayload>
        }
        createMany: {
          args: Prisma.maintenanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.maintenanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenancePayload>
        }
        update: {
          args: Prisma.maintenanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenancePayload>
        }
        deleteMany: {
          args: Prisma.maintenanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.maintenanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.maintenanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenancePayload>
        }
        aggregate: {
          args: Prisma.MaintenanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMaintenance>
        }
        groupBy: {
          args: Prisma.maintenanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MaintenanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.maintenanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MaintenanceCountAggregateOutputType> | number
        }
      }
    }
    maintenance_payment: {
      payload: Prisma.$maintenance_paymentPayload<ExtArgs>
      fields: Prisma.maintenance_paymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.maintenance_paymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_paymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.maintenance_paymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_paymentPayload>
        }
        findFirst: {
          args: Prisma.maintenance_paymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_paymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.maintenance_paymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_paymentPayload>
        }
        findMany: {
          args: Prisma.maintenance_paymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_paymentPayload>[]
        }
        create: {
          args: Prisma.maintenance_paymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_paymentPayload>
        }
        createMany: {
          args: Prisma.maintenance_paymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.maintenance_paymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_paymentPayload>
        }
        update: {
          args: Prisma.maintenance_paymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_paymentPayload>
        }
        deleteMany: {
          args: Prisma.maintenance_paymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.maintenance_paymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.maintenance_paymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$maintenance_paymentPayload>
        }
        aggregate: {
          args: Prisma.Maintenance_paymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMaintenance_payment>
        }
        groupBy: {
          args: Prisma.maintenance_paymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Maintenance_paymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.maintenance_paymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Maintenance_paymentCountAggregateOutputType> | number
        }
      }
    }
    payment_order: {
      payload: Prisma.$payment_orderPayload<ExtArgs>
      fields: Prisma.payment_orderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.payment_orderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_orderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.payment_orderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_orderPayload>
        }
        findFirst: {
          args: Prisma.payment_orderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_orderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.payment_orderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_orderPayload>
        }
        findMany: {
          args: Prisma.payment_orderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_orderPayload>[]
        }
        create: {
          args: Prisma.payment_orderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_orderPayload>
        }
        createMany: {
          args: Prisma.payment_orderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.payment_orderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_orderPayload>
        }
        update: {
          args: Prisma.payment_orderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_orderPayload>
        }
        deleteMany: {
          args: Prisma.payment_orderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.payment_orderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.payment_orderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_orderPayload>
        }
        aggregate: {
          args: Prisma.Payment_orderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayment_order>
        }
        groupBy: {
          args: Prisma.payment_orderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Payment_orderGroupByOutputType>[]
        }
        count: {
          args: Prisma.payment_orderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Payment_orderCountAggregateOutputType> | number
        }
      }
    }
    payment_order_person: {
      payload: Prisma.$payment_order_personPayload<ExtArgs>
      fields: Prisma.payment_order_personFieldRefs
      operations: {
        findUnique: {
          args: Prisma.payment_order_personFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_order_personPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.payment_order_personFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_order_personPayload>
        }
        findFirst: {
          args: Prisma.payment_order_personFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_order_personPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.payment_order_personFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_order_personPayload>
        }
        findMany: {
          args: Prisma.payment_order_personFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_order_personPayload>[]
        }
        create: {
          args: Prisma.payment_order_personCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_order_personPayload>
        }
        createMany: {
          args: Prisma.payment_order_personCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.payment_order_personDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_order_personPayload>
        }
        update: {
          args: Prisma.payment_order_personUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_order_personPayload>
        }
        deleteMany: {
          args: Prisma.payment_order_personDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.payment_order_personUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.payment_order_personUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_order_personPayload>
        }
        aggregate: {
          args: Prisma.Payment_order_personAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayment_order_person>
        }
        groupBy: {
          args: Prisma.payment_order_personGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Payment_order_personGroupByOutputType>[]
        }
        count: {
          args: Prisma.payment_order_personCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Payment_order_personCountAggregateOutputType> | number
        }
      }
    }
    payment_type: {
      payload: Prisma.$payment_typePayload<ExtArgs>
      fields: Prisma.payment_typeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.payment_typeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_typePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.payment_typeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_typePayload>
        }
        findFirst: {
          args: Prisma.payment_typeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_typePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.payment_typeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_typePayload>
        }
        findMany: {
          args: Prisma.payment_typeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_typePayload>[]
        }
        create: {
          args: Prisma.payment_typeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_typePayload>
        }
        createMany: {
          args: Prisma.payment_typeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.payment_typeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_typePayload>
        }
        update: {
          args: Prisma.payment_typeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_typePayload>
        }
        deleteMany: {
          args: Prisma.payment_typeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.payment_typeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.payment_typeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$payment_typePayload>
        }
        aggregate: {
          args: Prisma.Payment_typeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayment_type>
        }
        groupBy: {
          args: Prisma.payment_typeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Payment_typeGroupByOutputType>[]
        }
        count: {
          args: Prisma.payment_typeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Payment_typeCountAggregateOutputType> | number
        }
      }
    }
    permission_type: {
      payload: Prisma.$permission_typePayload<ExtArgs>
      fields: Prisma.permission_typeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.permission_typeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permission_typePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.permission_typeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permission_typePayload>
        }
        findFirst: {
          args: Prisma.permission_typeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permission_typePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.permission_typeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permission_typePayload>
        }
        findMany: {
          args: Prisma.permission_typeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permission_typePayload>[]
        }
        create: {
          args: Prisma.permission_typeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permission_typePayload>
        }
        createMany: {
          args: Prisma.permission_typeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.permission_typeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permission_typePayload>
        }
        update: {
          args: Prisma.permission_typeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permission_typePayload>
        }
        deleteMany: {
          args: Prisma.permission_typeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.permission_typeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.permission_typeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$permission_typePayload>
        }
        aggregate: {
          args: Prisma.Permission_typeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePermission_type>
        }
        groupBy: {
          args: Prisma.permission_typeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Permission_typeGroupByOutputType>[]
        }
        count: {
          args: Prisma.permission_typeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Permission_typeCountAggregateOutputType> | number
        }
      }
    }
    person: {
      payload: Prisma.$personPayload<ExtArgs>
      fields: Prisma.personFieldRefs
      operations: {
        findUnique: {
          args: Prisma.personFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$personPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.personFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$personPayload>
        }
        findFirst: {
          args: Prisma.personFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$personPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.personFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$personPayload>
        }
        findMany: {
          args: Prisma.personFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$personPayload>[]
        }
        create: {
          args: Prisma.personCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$personPayload>
        }
        createMany: {
          args: Prisma.personCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.personDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$personPayload>
        }
        update: {
          args: Prisma.personUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$personPayload>
        }
        deleteMany: {
          args: Prisma.personDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.personUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.personUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$personPayload>
        }
        aggregate: {
          args: Prisma.PersonAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePerson>
        }
        groupBy: {
          args: Prisma.personGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PersonGroupByOutputType>[]
        }
        count: {
          args: Prisma.personCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PersonCountAggregateOutputType> | number
        }
      }
    }
    person_email: {
      payload: Prisma.$person_emailPayload<ExtArgs>
      fields: Prisma.person_emailFieldRefs
      operations: {
        findUnique: {
          args: Prisma.person_emailFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_emailPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.person_emailFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_emailPayload>
        }
        findFirst: {
          args: Prisma.person_emailFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_emailPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.person_emailFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_emailPayload>
        }
        findMany: {
          args: Prisma.person_emailFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_emailPayload>[]
        }
        create: {
          args: Prisma.person_emailCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_emailPayload>
        }
        createMany: {
          args: Prisma.person_emailCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.person_emailDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_emailPayload>
        }
        update: {
          args: Prisma.person_emailUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_emailPayload>
        }
        deleteMany: {
          args: Prisma.person_emailDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.person_emailUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.person_emailUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_emailPayload>
        }
        aggregate: {
          args: Prisma.Person_emailAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePerson_email>
        }
        groupBy: {
          args: Prisma.person_emailGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Person_emailGroupByOutputType>[]
        }
        count: {
          args: Prisma.person_emailCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Person_emailCountAggregateOutputType> | number
        }
      }
    }
    person_phone: {
      payload: Prisma.$person_phonePayload<ExtArgs>
      fields: Prisma.person_phoneFieldRefs
      operations: {
        findUnique: {
          args: Prisma.person_phoneFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_phonePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.person_phoneFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_phonePayload>
        }
        findFirst: {
          args: Prisma.person_phoneFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_phonePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.person_phoneFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_phonePayload>
        }
        findMany: {
          args: Prisma.person_phoneFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_phonePayload>[]
        }
        create: {
          args: Prisma.person_phoneCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_phonePayload>
        }
        createMany: {
          args: Prisma.person_phoneCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.person_phoneDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_phonePayload>
        }
        update: {
          args: Prisma.person_phoneUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_phonePayload>
        }
        deleteMany: {
          args: Prisma.person_phoneDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.person_phoneUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.person_phoneUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$person_phonePayload>
        }
        aggregate: {
          args: Prisma.Person_phoneAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePerson_phone>
        }
        groupBy: {
          args: Prisma.person_phoneGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Person_phoneGroupByOutputType>[]
        }
        count: {
          args: Prisma.person_phoneCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Person_phoneCountAggregateOutputType> | number
        }
      }
    }
    property: {
      payload: Prisma.$propertyPayload<ExtArgs>
      fields: Prisma.propertyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.propertyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$propertyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.propertyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$propertyPayload>
        }
        findFirst: {
          args: Prisma.propertyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$propertyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.propertyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$propertyPayload>
        }
        findMany: {
          args: Prisma.propertyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$propertyPayload>[]
        }
        create: {
          args: Prisma.propertyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$propertyPayload>
        }
        createMany: {
          args: Prisma.propertyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.propertyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$propertyPayload>
        }
        update: {
          args: Prisma.propertyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$propertyPayload>
        }
        deleteMany: {
          args: Prisma.propertyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.propertyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.propertyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$propertyPayload>
        }
        aggregate: {
          args: Prisma.PropertyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProperty>
        }
        groupBy: {
          args: Prisma.propertyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyGroupByOutputType>[]
        }
        count: {
          args: Prisma.propertyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PropertyCountAggregateOutputType> | number
        }
      }
    }
    property_bank_account: {
      payload: Prisma.$property_bank_accountPayload<ExtArgs>
      fields: Prisma.property_bank_accountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.property_bank_accountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_bank_accountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.property_bank_accountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_bank_accountPayload>
        }
        findFirst: {
          args: Prisma.property_bank_accountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_bank_accountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.property_bank_accountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_bank_accountPayload>
        }
        findMany: {
          args: Prisma.property_bank_accountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_bank_accountPayload>[]
        }
        create: {
          args: Prisma.property_bank_accountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_bank_accountPayload>
        }
        createMany: {
          args: Prisma.property_bank_accountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.property_bank_accountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_bank_accountPayload>
        }
        update: {
          args: Prisma.property_bank_accountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_bank_accountPayload>
        }
        deleteMany: {
          args: Prisma.property_bank_accountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.property_bank_accountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.property_bank_accountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_bank_accountPayload>
        }
        aggregate: {
          args: Prisma.Property_bank_accountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProperty_bank_account>
        }
        groupBy: {
          args: Prisma.property_bank_accountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Property_bank_accountGroupByOutputType>[]
        }
        count: {
          args: Prisma.property_bank_accountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Property_bank_accountCountAggregateOutputType> | number
        }
      }
    }
    property_item: {
      payload: Prisma.$property_itemPayload<ExtArgs>
      fields: Prisma.property_itemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.property_itemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_itemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.property_itemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_itemPayload>
        }
        findFirst: {
          args: Prisma.property_itemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_itemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.property_itemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_itemPayload>
        }
        findMany: {
          args: Prisma.property_itemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_itemPayload>[]
        }
        create: {
          args: Prisma.property_itemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_itemPayload>
        }
        createMany: {
          args: Prisma.property_itemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.property_itemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_itemPayload>
        }
        update: {
          args: Prisma.property_itemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_itemPayload>
        }
        deleteMany: {
          args: Prisma.property_itemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.property_itemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.property_itemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_itemPayload>
        }
        aggregate: {
          args: Prisma.Property_itemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProperty_item>
        }
        groupBy: {
          args: Prisma.property_itemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Property_itemGroupByOutputType>[]
        }
        count: {
          args: Prisma.property_itemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Property_itemCountAggregateOutputType> | number
        }
      }
    }
    property_item_type: {
      payload: Prisma.$property_item_typePayload<ExtArgs>
      fields: Prisma.property_item_typeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.property_item_typeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_item_typePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.property_item_typeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_item_typePayload>
        }
        findFirst: {
          args: Prisma.property_item_typeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_item_typePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.property_item_typeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_item_typePayload>
        }
        findMany: {
          args: Prisma.property_item_typeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_item_typePayload>[]
        }
        create: {
          args: Prisma.property_item_typeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_item_typePayload>
        }
        createMany: {
          args: Prisma.property_item_typeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.property_item_typeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_item_typePayload>
        }
        update: {
          args: Prisma.property_item_typeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_item_typePayload>
        }
        deleteMany: {
          args: Prisma.property_item_typeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.property_item_typeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.property_item_typeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_item_typePayload>
        }
        aggregate: {
          args: Prisma.Property_item_typeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProperty_item_type>
        }
        groupBy: {
          args: Prisma.property_item_typeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Property_item_typeGroupByOutputType>[]
        }
        count: {
          args: Prisma.property_item_typeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Property_item_typeCountAggregateOutputType> | number
        }
      }
    }
    property_payment_config: {
      payload: Prisma.$property_payment_configPayload<ExtArgs>
      fields: Prisma.property_payment_configFieldRefs
      operations: {
        findUnique: {
          args: Prisma.property_payment_configFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_payment_configPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.property_payment_configFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_payment_configPayload>
        }
        findFirst: {
          args: Prisma.property_payment_configFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_payment_configPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.property_payment_configFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_payment_configPayload>
        }
        findMany: {
          args: Prisma.property_payment_configFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_payment_configPayload>[]
        }
        create: {
          args: Prisma.property_payment_configCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_payment_configPayload>
        }
        createMany: {
          args: Prisma.property_payment_configCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.property_payment_configDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_payment_configPayload>
        }
        update: {
          args: Prisma.property_payment_configUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_payment_configPayload>
        }
        deleteMany: {
          args: Prisma.property_payment_configDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.property_payment_configUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.property_payment_configUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_payment_configPayload>
        }
        aggregate: {
          args: Prisma.Property_payment_configAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProperty_payment_config>
        }
        groupBy: {
          args: Prisma.property_payment_configGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Property_payment_configGroupByOutputType>[]
        }
        count: {
          args: Prisma.property_payment_configCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Property_payment_configCountAggregateOutputType> | number
        }
      }
    }
    property_type: {
      payload: Prisma.$property_typePayload<ExtArgs>
      fields: Prisma.property_typeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.property_typeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_typePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.property_typeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_typePayload>
        }
        findFirst: {
          args: Prisma.property_typeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_typePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.property_typeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_typePayload>
        }
        findMany: {
          args: Prisma.property_typeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_typePayload>[]
        }
        create: {
          args: Prisma.property_typeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_typePayload>
        }
        createMany: {
          args: Prisma.property_typeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.property_typeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_typePayload>
        }
        update: {
          args: Prisma.property_typeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_typePayload>
        }
        deleteMany: {
          args: Prisma.property_typeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.property_typeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.property_typeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$property_typePayload>
        }
        aggregate: {
          args: Prisma.Property_typeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProperty_type>
        }
        groupBy: {
          args: Prisma.property_typeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Property_typeGroupByOutputType>[]
        }
        count: {
          args: Prisma.property_typeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Property_typeCountAggregateOutputType> | number
        }
      }
    }
    provider: {
      payload: Prisma.$providerPayload<ExtArgs>
      fields: Prisma.providerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.providerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$providerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.providerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$providerPayload>
        }
        findFirst: {
          args: Prisma.providerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$providerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.providerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$providerPayload>
        }
        findMany: {
          args: Prisma.providerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$providerPayload>[]
        }
        create: {
          args: Prisma.providerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$providerPayload>
        }
        createMany: {
          args: Prisma.providerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.providerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$providerPayload>
        }
        update: {
          args: Prisma.providerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$providerPayload>
        }
        deleteMany: {
          args: Prisma.providerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.providerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.providerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$providerPayload>
        }
        aggregate: {
          args: Prisma.ProviderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProvider>
        }
        groupBy: {
          args: Prisma.providerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProviderGroupByOutputType>[]
        }
        count: {
          args: Prisma.providerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProviderCountAggregateOutputType> | number
        }
      }
    }
    provider_bank_account: {
      payload: Prisma.$provider_bank_accountPayload<ExtArgs>
      fields: Prisma.provider_bank_accountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.provider_bank_accountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_bank_accountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.provider_bank_accountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_bank_accountPayload>
        }
        findFirst: {
          args: Prisma.provider_bank_accountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_bank_accountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.provider_bank_accountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_bank_accountPayload>
        }
        findMany: {
          args: Prisma.provider_bank_accountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_bank_accountPayload>[]
        }
        create: {
          args: Prisma.provider_bank_accountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_bank_accountPayload>
        }
        createMany: {
          args: Prisma.provider_bank_accountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.provider_bank_accountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_bank_accountPayload>
        }
        update: {
          args: Prisma.provider_bank_accountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_bank_accountPayload>
        }
        deleteMany: {
          args: Prisma.provider_bank_accountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.provider_bank_accountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.provider_bank_accountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_bank_accountPayload>
        }
        aggregate: {
          args: Prisma.Provider_bank_accountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProvider_bank_account>
        }
        groupBy: {
          args: Prisma.provider_bank_accountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Provider_bank_accountGroupByOutputType>[]
        }
        count: {
          args: Prisma.provider_bank_accountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Provider_bank_accountCountAggregateOutputType> | number
        }
      }
    }
    provider_category: {
      payload: Prisma.$provider_categoryPayload<ExtArgs>
      fields: Prisma.provider_categoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.provider_categoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_categoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.provider_categoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_categoryPayload>
        }
        findFirst: {
          args: Prisma.provider_categoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_categoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.provider_categoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_categoryPayload>
        }
        findMany: {
          args: Prisma.provider_categoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_categoryPayload>[]
        }
        create: {
          args: Prisma.provider_categoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_categoryPayload>
        }
        createMany: {
          args: Prisma.provider_categoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.provider_categoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_categoryPayload>
        }
        update: {
          args: Prisma.provider_categoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_categoryPayload>
        }
        deleteMany: {
          args: Prisma.provider_categoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.provider_categoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.provider_categoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_categoryPayload>
        }
        aggregate: {
          args: Prisma.Provider_categoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProvider_category>
        }
        groupBy: {
          args: Prisma.provider_categoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Provider_categoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.provider_categoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Provider_categoryCountAggregateOutputType> | number
        }
      }
    }
    provider_provider_category: {
      payload: Prisma.$provider_provider_categoryPayload<ExtArgs>
      fields: Prisma.provider_provider_categoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.provider_provider_categoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_provider_categoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.provider_provider_categoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_provider_categoryPayload>
        }
        findFirst: {
          args: Prisma.provider_provider_categoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_provider_categoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.provider_provider_categoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_provider_categoryPayload>
        }
        findMany: {
          args: Prisma.provider_provider_categoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_provider_categoryPayload>[]
        }
        create: {
          args: Prisma.provider_provider_categoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_provider_categoryPayload>
        }
        createMany: {
          args: Prisma.provider_provider_categoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.provider_provider_categoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_provider_categoryPayload>
        }
        update: {
          args: Prisma.provider_provider_categoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_provider_categoryPayload>
        }
        deleteMany: {
          args: Prisma.provider_provider_categoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.provider_provider_categoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.provider_provider_categoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$provider_provider_categoryPayload>
        }
        aggregate: {
          args: Prisma.Provider_provider_categoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProvider_provider_category>
        }
        groupBy: {
          args: Prisma.provider_provider_categoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Provider_provider_categoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.provider_provider_categoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Provider_provider_categoryCountAggregateOutputType> | number
        }
      }
    }
    receipt: {
      payload: Prisma.$receiptPayload<ExtArgs>
      fields: Prisma.receiptFieldRefs
      operations: {
        findUnique: {
          args: Prisma.receiptFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receiptPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.receiptFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receiptPayload>
        }
        findFirst: {
          args: Prisma.receiptFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receiptPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.receiptFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receiptPayload>
        }
        findMany: {
          args: Prisma.receiptFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receiptPayload>[]
        }
        create: {
          args: Prisma.receiptCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receiptPayload>
        }
        createMany: {
          args: Prisma.receiptCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.receiptDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receiptPayload>
        }
        update: {
          args: Prisma.receiptUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receiptPayload>
        }
        deleteMany: {
          args: Prisma.receiptDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.receiptUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.receiptUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receiptPayload>
        }
        aggregate: {
          args: Prisma.ReceiptAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReceipt>
        }
        groupBy: {
          args: Prisma.receiptGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceiptGroupByOutputType>[]
        }
        count: {
          args: Prisma.receiptCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReceiptCountAggregateOutputType> | number
        }
      }
    }
    receipt_detail: {
      payload: Prisma.$receipt_detailPayload<ExtArgs>
      fields: Prisma.receipt_detailFieldRefs
      operations: {
        findUnique: {
          args: Prisma.receipt_detailFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receipt_detailPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.receipt_detailFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receipt_detailPayload>
        }
        findFirst: {
          args: Prisma.receipt_detailFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receipt_detailPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.receipt_detailFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receipt_detailPayload>
        }
        findMany: {
          args: Prisma.receipt_detailFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receipt_detailPayload>[]
        }
        create: {
          args: Prisma.receipt_detailCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receipt_detailPayload>
        }
        createMany: {
          args: Prisma.receipt_detailCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.receipt_detailDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receipt_detailPayload>
        }
        update: {
          args: Prisma.receipt_detailUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receipt_detailPayload>
        }
        deleteMany: {
          args: Prisma.receipt_detailDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.receipt_detailUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.receipt_detailUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$receipt_detailPayload>
        }
        aggregate: {
          args: Prisma.Receipt_detailAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReceipt_detail>
        }
        groupBy: {
          args: Prisma.receipt_detailGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Receipt_detailGroupByOutputType>[]
        }
        count: {
          args: Prisma.receipt_detailCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Receipt_detailCountAggregateOutputType> | number
        }
      }
    }
    role: {
      payload: Prisma.$rolePayload<ExtArgs>
      fields: Prisma.roleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.roleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolePayload>
        }
        findFirst: {
          args: Prisma.roleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolePayload>
        }
        findMany: {
          args: Prisma.roleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolePayload>[]
        }
        create: {
          args: Prisma.roleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolePayload>
        }
        createMany: {
          args: Prisma.roleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.roleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolePayload>
        }
        update: {
          args: Prisma.roleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolePayload>
        }
        deleteMany: {
          args: Prisma.roleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.roleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.roleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$rolePayload>
        }
        aggregate: {
          args: Prisma.RoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRole>
        }
        groupBy: {
          args: Prisma.roleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.roleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleCountAggregateOutputType> | number
        }
      }
    }
    role_permission: {
      payload: Prisma.$role_permissionPayload<ExtArgs>
      fields: Prisma.role_permissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.role_permissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.role_permissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionPayload>
        }
        findFirst: {
          args: Prisma.role_permissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.role_permissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionPayload>
        }
        findMany: {
          args: Prisma.role_permissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionPayload>[]
        }
        create: {
          args: Prisma.role_permissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionPayload>
        }
        createMany: {
          args: Prisma.role_permissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.role_permissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionPayload>
        }
        update: {
          args: Prisma.role_permissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionPayload>
        }
        deleteMany: {
          args: Prisma.role_permissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.role_permissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.role_permissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$role_permissionPayload>
        }
        aggregate: {
          args: Prisma.Role_permissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRole_permission>
        }
        groupBy: {
          args: Prisma.role_permissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Role_permissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.role_permissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Role_permissionCountAggregateOutputType> | number
        }
      }
    }
    screen: {
      payload: Prisma.$screenPayload<ExtArgs>
      fields: Prisma.screenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.screenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$screenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.screenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$screenPayload>
        }
        findFirst: {
          args: Prisma.screenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$screenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.screenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$screenPayload>
        }
        findMany: {
          args: Prisma.screenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$screenPayload>[]
        }
        create: {
          args: Prisma.screenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$screenPayload>
        }
        createMany: {
          args: Prisma.screenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.screenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$screenPayload>
        }
        update: {
          args: Prisma.screenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$screenPayload>
        }
        deleteMany: {
          args: Prisma.screenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.screenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.screenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$screenPayload>
        }
        aggregate: {
          args: Prisma.ScreenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateScreen>
        }
        groupBy: {
          args: Prisma.screenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScreenGroupByOutputType>[]
        }
        count: {
          args: Prisma.screenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ScreenCountAggregateOutputType> | number
        }
      }
    }
    service_contract: {
      payload: Prisma.$service_contractPayload<ExtArgs>
      fields: Prisma.service_contractFieldRefs
      operations: {
        findUnique: {
          args: Prisma.service_contractFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contractPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.service_contractFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contractPayload>
        }
        findFirst: {
          args: Prisma.service_contractFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contractPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.service_contractFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contractPayload>
        }
        findMany: {
          args: Prisma.service_contractFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contractPayload>[]
        }
        create: {
          args: Prisma.service_contractCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contractPayload>
        }
        createMany: {
          args: Prisma.service_contractCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.service_contractDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contractPayload>
        }
        update: {
          args: Prisma.service_contractUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contractPayload>
        }
        deleteMany: {
          args: Prisma.service_contractDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.service_contractUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.service_contractUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contractPayload>
        }
        aggregate: {
          args: Prisma.Service_contractAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateService_contract>
        }
        groupBy: {
          args: Prisma.service_contractGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Service_contractGroupByOutputType>[]
        }
        count: {
          args: Prisma.service_contractCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Service_contractCountAggregateOutputType> | number
        }
      }
    }
    service_contract_person: {
      payload: Prisma.$service_contract_personPayload<ExtArgs>
      fields: Prisma.service_contract_personFieldRefs
      operations: {
        findUnique: {
          args: Prisma.service_contract_personFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contract_personPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.service_contract_personFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contract_personPayload>
        }
        findFirst: {
          args: Prisma.service_contract_personFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contract_personPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.service_contract_personFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contract_personPayload>
        }
        findMany: {
          args: Prisma.service_contract_personFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contract_personPayload>[]
        }
        create: {
          args: Prisma.service_contract_personCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contract_personPayload>
        }
        createMany: {
          args: Prisma.service_contract_personCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.service_contract_personDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contract_personPayload>
        }
        update: {
          args: Prisma.service_contract_personUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contract_personPayload>
        }
        deleteMany: {
          args: Prisma.service_contract_personDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.service_contract_personUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.service_contract_personUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$service_contract_personPayload>
        }
        aggregate: {
          args: Prisma.Service_contract_personAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateService_contract_person>
        }
        groupBy: {
          args: Prisma.service_contract_personGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Service_contract_personGroupByOutputType>[]
        }
        count: {
          args: Prisma.service_contract_personCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Service_contract_personCountAggregateOutputType> | number
        }
      }
    }
    subproperty: {
      payload: Prisma.$subpropertyPayload<ExtArgs>
      fields: Prisma.subpropertyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.subpropertyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subpropertyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.subpropertyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subpropertyPayload>
        }
        findFirst: {
          args: Prisma.subpropertyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subpropertyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.subpropertyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subpropertyPayload>
        }
        findMany: {
          args: Prisma.subpropertyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subpropertyPayload>[]
        }
        create: {
          args: Prisma.subpropertyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subpropertyPayload>
        }
        createMany: {
          args: Prisma.subpropertyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.subpropertyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subpropertyPayload>
        }
        update: {
          args: Prisma.subpropertyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subpropertyPayload>
        }
        deleteMany: {
          args: Prisma.subpropertyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.subpropertyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.subpropertyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subpropertyPayload>
        }
        aggregate: {
          args: Prisma.SubpropertyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubproperty>
        }
        groupBy: {
          args: Prisma.subpropertyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubpropertyGroupByOutputType>[]
        }
        count: {
          args: Prisma.subpropertyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubpropertyCountAggregateOutputType> | number
        }
      }
    }
    subproperty_item: {
      payload: Prisma.$subproperty_itemPayload<ExtArgs>
      fields: Prisma.subproperty_itemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.subproperty_itemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_itemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.subproperty_itemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_itemPayload>
        }
        findFirst: {
          args: Prisma.subproperty_itemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_itemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.subproperty_itemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_itemPayload>
        }
        findMany: {
          args: Prisma.subproperty_itemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_itemPayload>[]
        }
        create: {
          args: Prisma.subproperty_itemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_itemPayload>
        }
        createMany: {
          args: Prisma.subproperty_itemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.subproperty_itemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_itemPayload>
        }
        update: {
          args: Prisma.subproperty_itemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_itemPayload>
        }
        deleteMany: {
          args: Prisma.subproperty_itemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.subproperty_itemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.subproperty_itemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_itemPayload>
        }
        aggregate: {
          args: Prisma.Subproperty_itemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubproperty_item>
        }
        groupBy: {
          args: Prisma.subproperty_itemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Subproperty_itemGroupByOutputType>[]
        }
        count: {
          args: Prisma.subproperty_itemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Subproperty_itemCountAggregateOutputType> | number
        }
      }
    }
    subproperty_person: {
      payload: Prisma.$subproperty_personPayload<ExtArgs>
      fields: Prisma.subproperty_personFieldRefs
      operations: {
        findUnique: {
          args: Prisma.subproperty_personFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_personPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.subproperty_personFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_personPayload>
        }
        findFirst: {
          args: Prisma.subproperty_personFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_personPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.subproperty_personFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_personPayload>
        }
        findMany: {
          args: Prisma.subproperty_personFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_personPayload>[]
        }
        create: {
          args: Prisma.subproperty_personCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_personPayload>
        }
        createMany: {
          args: Prisma.subproperty_personCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.subproperty_personDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_personPayload>
        }
        update: {
          args: Prisma.subproperty_personUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_personPayload>
        }
        deleteMany: {
          args: Prisma.subproperty_personDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.subproperty_personUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.subproperty_personUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_personPayload>
        }
        aggregate: {
          args: Prisma.Subproperty_personAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubproperty_person>
        }
        groupBy: {
          args: Prisma.subproperty_personGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Subproperty_personGroupByOutputType>[]
        }
        count: {
          args: Prisma.subproperty_personCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Subproperty_personCountAggregateOutputType> | number
        }
      }
    }
    subproperty_type: {
      payload: Prisma.$subproperty_typePayload<ExtArgs>
      fields: Prisma.subproperty_typeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.subproperty_typeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_typePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.subproperty_typeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_typePayload>
        }
        findFirst: {
          args: Prisma.subproperty_typeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_typePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.subproperty_typeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_typePayload>
        }
        findMany: {
          args: Prisma.subproperty_typeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_typePayload>[]
        }
        create: {
          args: Prisma.subproperty_typeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_typePayload>
        }
        createMany: {
          args: Prisma.subproperty_typeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.subproperty_typeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_typePayload>
        }
        update: {
          args: Prisma.subproperty_typeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_typePayload>
        }
        deleteMany: {
          args: Prisma.subproperty_typeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.subproperty_typeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.subproperty_typeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$subproperty_typePayload>
        }
        aggregate: {
          args: Prisma.Subproperty_typeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubproperty_type>
        }
        groupBy: {
          args: Prisma.subproperty_typeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Subproperty_typeGroupByOutputType>[]
        }
        count: {
          args: Prisma.subproperty_typeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Subproperty_typeCountAggregateOutputType> | number
        }
      }
    }
    user_account: {
      payload: Prisma.$user_accountPayload<ExtArgs>
      fields: Prisma.user_accountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.user_accountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_accountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.user_accountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_accountPayload>
        }
        findFirst: {
          args: Prisma.user_accountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_accountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.user_accountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_accountPayload>
        }
        findMany: {
          args: Prisma.user_accountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_accountPayload>[]
        }
        create: {
          args: Prisma.user_accountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_accountPayload>
        }
        createMany: {
          args: Prisma.user_accountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.user_accountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_accountPayload>
        }
        update: {
          args: Prisma.user_accountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_accountPayload>
        }
        deleteMany: {
          args: Prisma.user_accountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.user_accountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.user_accountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_accountPayload>
        }
        aggregate: {
          args: Prisma.User_accountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser_account>
        }
        groupBy: {
          args: Prisma.user_accountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.User_accountGroupByOutputType>[]
        }
        count: {
          args: Prisma.user_accountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.User_accountCountAggregateOutputType> | number
        }
      }
    }
    user_property_role: {
      payload: Prisma.$user_property_rolePayload<ExtArgs>
      fields: Prisma.user_property_roleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.user_property_roleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_property_rolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.user_property_roleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_property_rolePayload>
        }
        findFirst: {
          args: Prisma.user_property_roleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_property_rolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.user_property_roleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_property_rolePayload>
        }
        findMany: {
          args: Prisma.user_property_roleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_property_rolePayload>[]
        }
        create: {
          args: Prisma.user_property_roleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_property_rolePayload>
        }
        createMany: {
          args: Prisma.user_property_roleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.user_property_roleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_property_rolePayload>
        }
        update: {
          args: Prisma.user_property_roleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_property_rolePayload>
        }
        deleteMany: {
          args: Prisma.user_property_roleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.user_property_roleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.user_property_roleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$user_property_rolePayload>
        }
        aggregate: {
          args: Prisma.User_property_roleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser_property_role>
        }
        groupBy: {
          args: Prisma.user_property_roleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.User_property_roleGroupByOutputType>[]
        }
        count: {
          args: Prisma.user_property_roleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.User_property_roleCountAggregateOutputType> | number
        }
      }
    }
    vehicle: {
      payload: Prisma.$vehiclePayload<ExtArgs>
      fields: Prisma.vehicleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.vehicleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.vehicleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclePayload>
        }
        findFirst: {
          args: Prisma.vehicleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.vehicleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclePayload>
        }
        findMany: {
          args: Prisma.vehicleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclePayload>[]
        }
        create: {
          args: Prisma.vehicleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclePayload>
        }
        createMany: {
          args: Prisma.vehicleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.vehicleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclePayload>
        }
        update: {
          args: Prisma.vehicleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclePayload>
        }
        deleteMany: {
          args: Prisma.vehicleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.vehicleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.vehicleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehiclePayload>
        }
        aggregate: {
          args: Prisma.VehicleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicle>
        }
        groupBy: {
          args: Prisma.vehicleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleGroupByOutputType>[]
        }
        count: {
          args: Prisma.vehicleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleCountAggregateOutputType> | number
        }
      }
    }
    vehicle_type: {
      payload: Prisma.$vehicle_typePayload<ExtArgs>
      fields: Prisma.vehicle_typeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.vehicle_typeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_typePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.vehicle_typeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_typePayload>
        }
        findFirst: {
          args: Prisma.vehicle_typeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_typePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.vehicle_typeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_typePayload>
        }
        findMany: {
          args: Prisma.vehicle_typeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_typePayload>[]
        }
        create: {
          args: Prisma.vehicle_typeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_typePayload>
        }
        createMany: {
          args: Prisma.vehicle_typeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.vehicle_typeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_typePayload>
        }
        update: {
          args: Prisma.vehicle_typeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_typePayload>
        }
        deleteMany: {
          args: Prisma.vehicle_typeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.vehicle_typeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.vehicle_typeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$vehicle_typePayload>
        }
        aggregate: {
          args: Prisma.Vehicle_typeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicle_type>
        }
        groupBy: {
          args: Prisma.vehicle_typeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Vehicle_typeGroupByOutputType>[]
        }
        count: {
          args: Prisma.vehicle_typeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Vehicle_typeCountAggregateOutputType> | number
        }
      }
    }
    visit: {
      payload: Prisma.$visitPayload<ExtArgs>
      fields: Prisma.visitFieldRefs
      operations: {
        findUnique: {
          args: Prisma.visitFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visitPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.visitFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visitPayload>
        }
        findFirst: {
          args: Prisma.visitFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visitPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.visitFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visitPayload>
        }
        findMany: {
          args: Prisma.visitFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visitPayload>[]
        }
        create: {
          args: Prisma.visitCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visitPayload>
        }
        createMany: {
          args: Prisma.visitCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.visitDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visitPayload>
        }
        update: {
          args: Prisma.visitUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visitPayload>
        }
        deleteMany: {
          args: Prisma.visitDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.visitUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.visitUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visitPayload>
        }
        aggregate: {
          args: Prisma.VisitAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVisit>
        }
        groupBy: {
          args: Prisma.visitGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VisitGroupByOutputType>[]
        }
        count: {
          args: Prisma.visitCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VisitCountAggregateOutputType> | number
        }
      }
    }
    visit_type: {
      payload: Prisma.$visit_typePayload<ExtArgs>
      fields: Prisma.visit_typeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.visit_typeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visit_typePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.visit_typeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visit_typePayload>
        }
        findFirst: {
          args: Prisma.visit_typeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visit_typePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.visit_typeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visit_typePayload>
        }
        findMany: {
          args: Prisma.visit_typeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visit_typePayload>[]
        }
        create: {
          args: Prisma.visit_typeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visit_typePayload>
        }
        createMany: {
          args: Prisma.visit_typeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        delete: {
          args: Prisma.visit_typeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visit_typePayload>
        }
        update: {
          args: Prisma.visit_typeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visit_typePayload>
        }
        deleteMany: {
          args: Prisma.visit_typeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.visit_typeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        upsert: {
          args: Prisma.visit_typeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$visit_typePayload>
        }
        aggregate: {
          args: Prisma.Visit_typeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVisit_type>
        }
        groupBy: {
          args: Prisma.visit_typeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Visit_typeGroupByOutputType>[]
        }
        count: {
          args: Prisma.visit_typeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Visit_typeCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const Assignment_typeScalarFieldEnum = {
  assignment_type_id: 'assignment_type_id',
  code: 'code',
  name: 'name'
} as const

export type Assignment_typeScalarFieldEnum = (typeof Assignment_typeScalarFieldEnum)[keyof typeof Assignment_typeScalarFieldEnum]


export const Bank_accountScalarFieldEnum = {
  bank_account_id: 'bank_account_id',
  bank_name: 'bank_name',
  account_number: 'account_number',
  country_id: 'country_id',
  created_at: 'created_at'
} as const

export type Bank_accountScalarFieldEnum = (typeof Bank_accountScalarFieldEnum)[keyof typeof Bank_accountScalarFieldEnum]


export const CountryScalarFieldEnum = {
  country_id: 'country_id',
  name: 'name',
  iso_code: 'iso_code'
} as const

export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


export const MaintenanceScalarFieldEnum = {
  maintenance_id: 'maintenance_id',
  property_item_id: 'property_item_id',
  provider_id: 'provider_id',
  description: 'description',
  start_date: 'start_date',
  end_date: 'end_date',
  status: 'status'
} as const

export type MaintenanceScalarFieldEnum = (typeof MaintenanceScalarFieldEnum)[keyof typeof MaintenanceScalarFieldEnum]


export const Maintenance_paymentScalarFieldEnum = {
  maintenance_payment_id: 'maintenance_payment_id',
  maintenance_id: 'maintenance_id',
  receipt_detail_id: 'receipt_detail_id',
  provider_bank_account_id: 'provider_bank_account_id',
  amount: 'amount'
} as const

export type Maintenance_paymentScalarFieldEnum = (typeof Maintenance_paymentScalarFieldEnum)[keyof typeof Maintenance_paymentScalarFieldEnum]


export const Payment_orderScalarFieldEnum = {
  payment_order_id: 'payment_order_id',
  property_id: 'property_id',
  subproperty_id: 'subproperty_id',
  property_payment_config_id: 'property_payment_config_id',
  period_start_date: 'period_start_date',
  period_end_date: 'period_end_date',
  generation_date: 'generation_date',
  due_date: 'due_date',
  status: 'status',
  total_amount: 'total_amount',
  created_at: 'created_at'
} as const

export type Payment_orderScalarFieldEnum = (typeof Payment_orderScalarFieldEnum)[keyof typeof Payment_orderScalarFieldEnum]


export const Payment_order_personScalarFieldEnum = {
  payment_order_person_id: 'payment_order_person_id',
  payment_order_id: 'payment_order_id',
  person_id: 'person_id',
  responsibility_percentage: 'responsibility_percentage'
} as const

export type Payment_order_personScalarFieldEnum = (typeof Payment_order_personScalarFieldEnum)[keyof typeof Payment_order_personScalarFieldEnum]


export const Payment_typeScalarFieldEnum = {
  payment_type_id: 'payment_type_id',
  code: 'code',
  name: 'name'
} as const

export type Payment_typeScalarFieldEnum = (typeof Payment_typeScalarFieldEnum)[keyof typeof Payment_typeScalarFieldEnum]


export const Permission_typeScalarFieldEnum = {
  permission_type_id: 'permission_type_id',
  code: 'code',
  name: 'name'
} as const

export type Permission_typeScalarFieldEnum = (typeof Permission_typeScalarFieldEnum)[keyof typeof Permission_typeScalarFieldEnum]


export const PersonScalarFieldEnum = {
  person_id: 'person_id',
  first_name: 'first_name',
  last_name: 'last_name',
  birth_date: 'birth_date',
  dpi: 'dpi',
  country_id: 'country_id',
  notes: 'notes',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


export const Person_emailScalarFieldEnum = {
  person_email_id: 'person_email_id',
  person_id: 'person_id',
  email: 'email',
  is_primary: 'is_primary'
} as const

export type Person_emailScalarFieldEnum = (typeof Person_emailScalarFieldEnum)[keyof typeof Person_emailScalarFieldEnum]


export const Person_phoneScalarFieldEnum = {
  person_phone_id: 'person_phone_id',
  person_id: 'person_id',
  phone_type: 'phone_type',
  country_code: 'country_code',
  phone_number: 'phone_number',
  is_primary: 'is_primary'
} as const

export type Person_phoneScalarFieldEnum = (typeof Person_phoneScalarFieldEnum)[keyof typeof Person_phoneScalarFieldEnum]


export const PropertyScalarFieldEnum = {
  property_id: 'property_id',
  property_type_id: 'property_type_id',
  name: 'name',
  address_line1: 'address_line1',
  address_line2: 'address_line2',
  city: 'city',
  state: 'state',
  postal_code: 'postal_code',
  country_id: 'country_id',
  status: 'status',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


export const Property_bank_accountScalarFieldEnum = {
  property_bank_account_id: 'property_bank_account_id',
  property_id: 'property_id',
  bank_account_id: 'bank_account_id'
} as const

export type Property_bank_accountScalarFieldEnum = (typeof Property_bank_accountScalarFieldEnum)[keyof typeof Property_bank_accountScalarFieldEnum]


export const Property_itemScalarFieldEnum = {
  property_item_id: 'property_item_id',
  property_id: 'property_id',
  property_item_type_id: 'property_item_type_id',
  name: 'name',
  location_description: 'location_description',
  status: 'status',
  created_at: 'created_at'
} as const

export type Property_itemScalarFieldEnum = (typeof Property_itemScalarFieldEnum)[keyof typeof Property_itemScalarFieldEnum]


export const Property_item_typeScalarFieldEnum = {
  property_item_type_id: 'property_item_type_id',
  code: 'code',
  name: 'name'
} as const

export type Property_item_typeScalarFieldEnum = (typeof Property_item_typeScalarFieldEnum)[keyof typeof Property_item_typeScalarFieldEnum]


export const Property_payment_configScalarFieldEnum = {
  property_payment_config_id: 'property_payment_config_id',
  property_id: 'property_id',
  payment_type_id: 'payment_type_id',
  description: 'description',
  default_amount: 'default_amount',
  start_date: 'start_date',
  end_date: 'end_date',
  status: 'status'
} as const

export type Property_payment_configScalarFieldEnum = (typeof Property_payment_configScalarFieldEnum)[keyof typeof Property_payment_configScalarFieldEnum]


export const Property_typeScalarFieldEnum = {
  property_type_id: 'property_type_id',
  code: 'code',
  name: 'name'
} as const

export type Property_typeScalarFieldEnum = (typeof Property_typeScalarFieldEnum)[keyof typeof Property_typeScalarFieldEnum]


export const ProviderScalarFieldEnum = {
  provider_id: 'provider_id',
  name: 'name',
  address_line1: 'address_line1',
  address_line2: 'address_line2',
  city: 'city',
  state: 'state',
  postal_code: 'postal_code',
  country_id: 'country_id',
  tax_id: 'tax_id',
  status: 'status'
} as const

export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


export const Provider_bank_accountScalarFieldEnum = {
  provider_bank_account_id: 'provider_bank_account_id',
  provider_id: 'provider_id',
  bank_account_id: 'bank_account_id'
} as const

export type Provider_bank_accountScalarFieldEnum = (typeof Provider_bank_accountScalarFieldEnum)[keyof typeof Provider_bank_accountScalarFieldEnum]


export const Provider_categoryScalarFieldEnum = {
  provider_category_id: 'provider_category_id',
  code: 'code',
  name: 'name'
} as const

export type Provider_categoryScalarFieldEnum = (typeof Provider_categoryScalarFieldEnum)[keyof typeof Provider_categoryScalarFieldEnum]


export const Provider_provider_categoryScalarFieldEnum = {
  provider_id: 'provider_id',
  provider_category_id: 'provider_category_id'
} as const

export type Provider_provider_categoryScalarFieldEnum = (typeof Provider_provider_categoryScalarFieldEnum)[keyof typeof Provider_provider_categoryScalarFieldEnum]


export const ReceiptScalarFieldEnum = {
  receipt_id: 'receipt_id',
  property_id: 'property_id',
  subproperty_id: 'subproperty_id',
  payer_person_id: 'payer_person_id',
  property_bank_account_id: 'property_bank_account_id',
  receipt_date: 'receipt_date',
  status: 'status',
  total_amount: 'total_amount',
  reference_number: 'reference_number',
  created_at: 'created_at'
} as const

export type ReceiptScalarFieldEnum = (typeof ReceiptScalarFieldEnum)[keyof typeof ReceiptScalarFieldEnum]


export const Receipt_detailScalarFieldEnum = {
  receipt_detail_id: 'receipt_detail_id',
  receipt_id: 'receipt_id',
  payment_order_id: 'payment_order_id',
  payment_type_id: 'payment_type_id',
  amount: 'amount'
} as const

export type Receipt_detailScalarFieldEnum = (typeof Receipt_detailScalarFieldEnum)[keyof typeof Receipt_detailScalarFieldEnum]


export const RoleScalarFieldEnum = {
  role_id: 'role_id',
  code: 'code',
  name: 'name'
} as const

export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


export const Role_permissionScalarFieldEnum = {
  role_permission_id: 'role_permission_id',
  role_id: 'role_id',
  screen_id: 'screen_id',
  permission_type_id: 'permission_type_id'
} as const

export type Role_permissionScalarFieldEnum = (typeof Role_permissionScalarFieldEnum)[keyof typeof Role_permissionScalarFieldEnum]


export const ScreenScalarFieldEnum = {
  screen_id: 'screen_id',
  code: 'code',
  name: 'name'
} as const

export type ScreenScalarFieldEnum = (typeof ScreenScalarFieldEnum)[keyof typeof ScreenScalarFieldEnum]


export const Service_contractScalarFieldEnum = {
  service_contract_id: 'service_contract_id',
  property_id: 'property_id',
  provider_id: 'provider_id',
  contract_name: 'contract_name',
  contract_number: 'contract_number',
  terms_text: 'terms_text',
  start_date: 'start_date',
  end_date: 'end_date',
  status: 'status',
  contract_country_id: 'contract_country_id'
} as const

export type Service_contractScalarFieldEnum = (typeof Service_contractScalarFieldEnum)[keyof typeof Service_contractScalarFieldEnum]


export const Service_contract_personScalarFieldEnum = {
  service_contract_person_id: 'service_contract_person_id',
  service_contract_id: 'service_contract_id',
  person_id: 'person_id',
  role_in_contract: 'role_in_contract',
  start_date: 'start_date',
  end_date: 'end_date',
  is_active: 'is_active'
} as const

export type Service_contract_personScalarFieldEnum = (typeof Service_contract_personScalarFieldEnum)[keyof typeof Service_contract_personScalarFieldEnum]


export const SubpropertyScalarFieldEnum = {
  subproperty_id: 'subproperty_id',
  property_id: 'property_id',
  subproperty_type_id: 'subproperty_type_id',
  code: 'code',
  floor: 'floor',
  tower: 'tower',
  area_m2: 'area_m2',
  status: 'status',
  created_at: 'created_at',
  updated_at: 'updated_at'
} as const

export type SubpropertyScalarFieldEnum = (typeof SubpropertyScalarFieldEnum)[keyof typeof SubpropertyScalarFieldEnum]


export const Subproperty_itemScalarFieldEnum = {
  subproperty_item_id: 'subproperty_item_id',
  subproperty_id: 'subproperty_id',
  property_item_id: 'property_item_id',
  assignment_type: 'assignment_type'
} as const

export type Subproperty_itemScalarFieldEnum = (typeof Subproperty_itemScalarFieldEnum)[keyof typeof Subproperty_itemScalarFieldEnum]


export const Subproperty_personScalarFieldEnum = {
  subproperty_person_id: 'subproperty_person_id',
  subproperty_id: 'subproperty_id',
  person_id: 'person_id',
  assignment_type_id: 'assignment_type_id',
  start_date: 'start_date',
  end_date: 'end_date',
  is_active: 'is_active'
} as const

export type Subproperty_personScalarFieldEnum = (typeof Subproperty_personScalarFieldEnum)[keyof typeof Subproperty_personScalarFieldEnum]


export const Subproperty_typeScalarFieldEnum = {
  subproperty_type_id: 'subproperty_type_id',
  code: 'code',
  name: 'name'
} as const

export type Subproperty_typeScalarFieldEnum = (typeof Subproperty_typeScalarFieldEnum)[keyof typeof Subproperty_typeScalarFieldEnum]


export const User_accountScalarFieldEnum = {
  user_id: 'user_id',
  username: 'username',
  password_hash: 'password_hash',
  first_name: 'first_name',
  last_name: 'last_name',
  email: 'email',
  person_id: 'person_id',
  is_active: 'is_active',
  created_at: 'created_at'
} as const

export type User_accountScalarFieldEnum = (typeof User_accountScalarFieldEnum)[keyof typeof User_accountScalarFieldEnum]


export const User_property_roleScalarFieldEnum = {
  user_property_role_id: 'user_property_role_id',
  user_id: 'user_id',
  property_id: 'property_id',
  role_id: 'role_id'
} as const

export type User_property_roleScalarFieldEnum = (typeof User_property_roleScalarFieldEnum)[keyof typeof User_property_roleScalarFieldEnum]


export const VehicleScalarFieldEnum = {
  vehicle_id: 'vehicle_id',
  vehicle_type_id: 'vehicle_type_id',
  plate: 'plate',
  brand: 'brand',
  model: 'model',
  color: 'color',
  person_id: 'person_id',
  subproperty_id: 'subproperty_id',
  created_at: 'created_at'
} as const

export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


export const Vehicle_typeScalarFieldEnum = {
  vehicle_type_id: 'vehicle_type_id',
  code: 'code',
  name: 'name'
} as const

export type Vehicle_typeScalarFieldEnum = (typeof Vehicle_typeScalarFieldEnum)[keyof typeof Vehicle_typeScalarFieldEnum]


export const VisitScalarFieldEnum = {
  visit_id: 'visit_id',
  property_id: 'property_id',
  subproperty_id: 'subproperty_id',
  property_item_id: 'property_item_id',
  visitor_name: 'visitor_name',
  visitor_dpi: 'visitor_dpi',
  visit_type_id: 'visit_type_id',
  entry_datetime: 'entry_datetime',
  exit_datetime: 'exit_datetime',
  authorized_staff_person_id: 'authorized_staff_person_id',
  authorized_resident_person_id: 'authorized_resident_person_id',
  created_by_user_id: 'created_by_user_id',
  created_at: 'created_at'
} as const

export type VisitScalarFieldEnum = (typeof VisitScalarFieldEnum)[keyof typeof VisitScalarFieldEnum]


export const Visit_typeScalarFieldEnum = {
  visit_type_id: 'visit_type_id',
  code: 'code',
  name: 'name'
} as const

export type Visit_typeScalarFieldEnum = (typeof Visit_typeScalarFieldEnum)[keyof typeof Visit_typeScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const assignment_typeOrderByRelevanceFieldEnum = {
  code: 'code',
  name: 'name'
} as const

export type assignment_typeOrderByRelevanceFieldEnum = (typeof assignment_typeOrderByRelevanceFieldEnum)[keyof typeof assignment_typeOrderByRelevanceFieldEnum]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const bank_accountOrderByRelevanceFieldEnum = {
  bank_name: 'bank_name',
  account_number: 'account_number'
} as const

export type bank_accountOrderByRelevanceFieldEnum = (typeof bank_accountOrderByRelevanceFieldEnum)[keyof typeof bank_accountOrderByRelevanceFieldEnum]


export const countryOrderByRelevanceFieldEnum = {
  name: 'name',
  iso_code: 'iso_code'
} as const

export type countryOrderByRelevanceFieldEnum = (typeof countryOrderByRelevanceFieldEnum)[keyof typeof countryOrderByRelevanceFieldEnum]


export const maintenanceOrderByRelevanceFieldEnum = {
  description: 'description',
  status: 'status'
} as const

export type maintenanceOrderByRelevanceFieldEnum = (typeof maintenanceOrderByRelevanceFieldEnum)[keyof typeof maintenanceOrderByRelevanceFieldEnum]


export const payment_orderOrderByRelevanceFieldEnum = {
  status: 'status'
} as const

export type payment_orderOrderByRelevanceFieldEnum = (typeof payment_orderOrderByRelevanceFieldEnum)[keyof typeof payment_orderOrderByRelevanceFieldEnum]


export const payment_typeOrderByRelevanceFieldEnum = {
  code: 'code',
  name: 'name'
} as const

export type payment_typeOrderByRelevanceFieldEnum = (typeof payment_typeOrderByRelevanceFieldEnum)[keyof typeof payment_typeOrderByRelevanceFieldEnum]


export const permission_typeOrderByRelevanceFieldEnum = {
  code: 'code',
  name: 'name'
} as const

export type permission_typeOrderByRelevanceFieldEnum = (typeof permission_typeOrderByRelevanceFieldEnum)[keyof typeof permission_typeOrderByRelevanceFieldEnum]


export const personOrderByRelevanceFieldEnum = {
  first_name: 'first_name',
  last_name: 'last_name',
  dpi: 'dpi',
  notes: 'notes'
} as const

export type personOrderByRelevanceFieldEnum = (typeof personOrderByRelevanceFieldEnum)[keyof typeof personOrderByRelevanceFieldEnum]


export const person_emailOrderByRelevanceFieldEnum = {
  email: 'email'
} as const

export type person_emailOrderByRelevanceFieldEnum = (typeof person_emailOrderByRelevanceFieldEnum)[keyof typeof person_emailOrderByRelevanceFieldEnum]


export const person_phoneOrderByRelevanceFieldEnum = {
  phone_type: 'phone_type',
  country_code: 'country_code',
  phone_number: 'phone_number'
} as const

export type person_phoneOrderByRelevanceFieldEnum = (typeof person_phoneOrderByRelevanceFieldEnum)[keyof typeof person_phoneOrderByRelevanceFieldEnum]


export const propertyOrderByRelevanceFieldEnum = {
  name: 'name',
  address_line1: 'address_line1',
  address_line2: 'address_line2',
  city: 'city',
  state: 'state',
  postal_code: 'postal_code',
  status: 'status'
} as const

export type propertyOrderByRelevanceFieldEnum = (typeof propertyOrderByRelevanceFieldEnum)[keyof typeof propertyOrderByRelevanceFieldEnum]


export const property_itemOrderByRelevanceFieldEnum = {
  name: 'name',
  location_description: 'location_description',
  status: 'status'
} as const

export type property_itemOrderByRelevanceFieldEnum = (typeof property_itemOrderByRelevanceFieldEnum)[keyof typeof property_itemOrderByRelevanceFieldEnum]


export const property_item_typeOrderByRelevanceFieldEnum = {
  code: 'code',
  name: 'name'
} as const

export type property_item_typeOrderByRelevanceFieldEnum = (typeof property_item_typeOrderByRelevanceFieldEnum)[keyof typeof property_item_typeOrderByRelevanceFieldEnum]


export const property_payment_configOrderByRelevanceFieldEnum = {
  description: 'description',
  status: 'status'
} as const

export type property_payment_configOrderByRelevanceFieldEnum = (typeof property_payment_configOrderByRelevanceFieldEnum)[keyof typeof property_payment_configOrderByRelevanceFieldEnum]


export const property_typeOrderByRelevanceFieldEnum = {
  code: 'code',
  name: 'name'
} as const

export type property_typeOrderByRelevanceFieldEnum = (typeof property_typeOrderByRelevanceFieldEnum)[keyof typeof property_typeOrderByRelevanceFieldEnum]


export const providerOrderByRelevanceFieldEnum = {
  name: 'name',
  address_line1: 'address_line1',
  address_line2: 'address_line2',
  city: 'city',
  state: 'state',
  postal_code: 'postal_code',
  tax_id: 'tax_id',
  status: 'status'
} as const

export type providerOrderByRelevanceFieldEnum = (typeof providerOrderByRelevanceFieldEnum)[keyof typeof providerOrderByRelevanceFieldEnum]


export const provider_categoryOrderByRelevanceFieldEnum = {
  code: 'code',
  name: 'name'
} as const

export type provider_categoryOrderByRelevanceFieldEnum = (typeof provider_categoryOrderByRelevanceFieldEnum)[keyof typeof provider_categoryOrderByRelevanceFieldEnum]


export const receiptOrderByRelevanceFieldEnum = {
  status: 'status',
  reference_number: 'reference_number'
} as const

export type receiptOrderByRelevanceFieldEnum = (typeof receiptOrderByRelevanceFieldEnum)[keyof typeof receiptOrderByRelevanceFieldEnum]


export const roleOrderByRelevanceFieldEnum = {
  code: 'code',
  name: 'name'
} as const

export type roleOrderByRelevanceFieldEnum = (typeof roleOrderByRelevanceFieldEnum)[keyof typeof roleOrderByRelevanceFieldEnum]


export const screenOrderByRelevanceFieldEnum = {
  code: 'code',
  name: 'name'
} as const

export type screenOrderByRelevanceFieldEnum = (typeof screenOrderByRelevanceFieldEnum)[keyof typeof screenOrderByRelevanceFieldEnum]


export const service_contractOrderByRelevanceFieldEnum = {
  contract_name: 'contract_name',
  contract_number: 'contract_number',
  terms_text: 'terms_text',
  status: 'status'
} as const

export type service_contractOrderByRelevanceFieldEnum = (typeof service_contractOrderByRelevanceFieldEnum)[keyof typeof service_contractOrderByRelevanceFieldEnum]


export const service_contract_personOrderByRelevanceFieldEnum = {
  role_in_contract: 'role_in_contract'
} as const

export type service_contract_personOrderByRelevanceFieldEnum = (typeof service_contract_personOrderByRelevanceFieldEnum)[keyof typeof service_contract_personOrderByRelevanceFieldEnum]


export const subpropertyOrderByRelevanceFieldEnum = {
  code: 'code',
  floor: 'floor',
  tower: 'tower',
  status: 'status'
} as const

export type subpropertyOrderByRelevanceFieldEnum = (typeof subpropertyOrderByRelevanceFieldEnum)[keyof typeof subpropertyOrderByRelevanceFieldEnum]


export const subproperty_itemOrderByRelevanceFieldEnum = {
  assignment_type: 'assignment_type'
} as const

export type subproperty_itemOrderByRelevanceFieldEnum = (typeof subproperty_itemOrderByRelevanceFieldEnum)[keyof typeof subproperty_itemOrderByRelevanceFieldEnum]


export const subproperty_typeOrderByRelevanceFieldEnum = {
  code: 'code',
  name: 'name'
} as const

export type subproperty_typeOrderByRelevanceFieldEnum = (typeof subproperty_typeOrderByRelevanceFieldEnum)[keyof typeof subproperty_typeOrderByRelevanceFieldEnum]


export const user_accountOrderByRelevanceFieldEnum = {
  username: 'username',
  password_hash: 'password_hash',
  first_name: 'first_name',
  last_name: 'last_name',
  email: 'email'
} as const

export type user_accountOrderByRelevanceFieldEnum = (typeof user_accountOrderByRelevanceFieldEnum)[keyof typeof user_accountOrderByRelevanceFieldEnum]


export const vehicleOrderByRelevanceFieldEnum = {
  plate: 'plate',
  brand: 'brand',
  model: 'model',
  color: 'color'
} as const

export type vehicleOrderByRelevanceFieldEnum = (typeof vehicleOrderByRelevanceFieldEnum)[keyof typeof vehicleOrderByRelevanceFieldEnum]


export const vehicle_typeOrderByRelevanceFieldEnum = {
  code: 'code',
  name: 'name'
} as const

export type vehicle_typeOrderByRelevanceFieldEnum = (typeof vehicle_typeOrderByRelevanceFieldEnum)[keyof typeof vehicle_typeOrderByRelevanceFieldEnum]


export const visitOrderByRelevanceFieldEnum = {
  visitor_name: 'visitor_name',
  visitor_dpi: 'visitor_dpi'
} as const

export type visitOrderByRelevanceFieldEnum = (typeof visitOrderByRelevanceFieldEnum)[keyof typeof visitOrderByRelevanceFieldEnum]


export const visit_typeOrderByRelevanceFieldEnum = {
  code: 'code',
  name: 'name'
} as const

export type visit_typeOrderByRelevanceFieldEnum = (typeof visit_typeOrderByRelevanceFieldEnum)[keyof typeof visit_typeOrderByRelevanceFieldEnum]



/**
 * Field references
 */


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  assignment_type?: Prisma.assignment_typeOmit
  bank_account?: Prisma.bank_accountOmit
  country?: Prisma.countryOmit
  maintenance?: Prisma.maintenanceOmit
  maintenance_payment?: Prisma.maintenance_paymentOmit
  payment_order?: Prisma.payment_orderOmit
  payment_order_person?: Prisma.payment_order_personOmit
  payment_type?: Prisma.payment_typeOmit
  permission_type?: Prisma.permission_typeOmit
  person?: Prisma.personOmit
  person_email?: Prisma.person_emailOmit
  person_phone?: Prisma.person_phoneOmit
  property?: Prisma.propertyOmit
  property_bank_account?: Prisma.property_bank_accountOmit
  property_item?: Prisma.property_itemOmit
  property_item_type?: Prisma.property_item_typeOmit
  property_payment_config?: Prisma.property_payment_configOmit
  property_type?: Prisma.property_typeOmit
  provider?: Prisma.providerOmit
  provider_bank_account?: Prisma.provider_bank_accountOmit
  provider_category?: Prisma.provider_categoryOmit
  provider_provider_category?: Prisma.provider_provider_categoryOmit
  receipt?: Prisma.receiptOmit
  receipt_detail?: Prisma.receipt_detailOmit
  role?: Prisma.roleOmit
  role_permission?: Prisma.role_permissionOmit
  screen?: Prisma.screenOmit
  service_contract?: Prisma.service_contractOmit
  service_contract_person?: Prisma.service_contract_personOmit
  subproperty?: Prisma.subpropertyOmit
  subproperty_item?: Prisma.subproperty_itemOmit
  subproperty_person?: Prisma.subproperty_personOmit
  subproperty_type?: Prisma.subproperty_typeOmit
  user_account?: Prisma.user_accountOmit
  user_property_role?: Prisma.user_property_roleOmit
  vehicle?: Prisma.vehicleOmit
  vehicle_type?: Prisma.vehicle_typeOmit
  visit?: Prisma.visitOmit
  visit_type?: Prisma.visit_typeOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

